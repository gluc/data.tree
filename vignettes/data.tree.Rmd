---
title: "Introduction to data.tree"
author: "Christoph Glur"
date: '`r Sys.Date()`'
output:
  html_document:
    includes:
      before_body: intro.banner.html
    self_contained: yes
    theme: cerulean
    toc: yes
    toc_depth: 3
  pdf_document:
    toc: yes
    toc_depth: 3
---

<!--
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{Quick introduction to data.tree}
-->

# Introduction

## Trees

Trees are ubiquitous in mathematics, computer science, data sciences, finance, and in many other fields. Trees are especially useful when we are facing *hierarchical data*. For example, trees are used:

* in decision theory (cf. decision trees)
* in machine learning (e.g. classification trees)
* in finance, e.g. to classify financial instruments into asset classes
* in routing algorithms
* in computer science and programming (e.g. binary search trees, XML)
* e.g. for family trees

For more details, see the applications vignette by typing `vignette("applications", package = "data.tree")`

## Trees in R

Tree-like structures are already used in R. For example, environments can be seen as nodes in a tree. And CRAN provides numerous packages that deal with tree-like structures, especially in the area of decision theory. Yet, there is no general purpose hierarchical data structure that could be used as conveniently and generically as, say, data.frame. 

As a result, people often try to resolve hierarchical problems in a tabular fashion, for instance with data.frames (or - perish the thought! - in Excel sheets). But often, hierarchies don't marry with tables and various workarounds are usually required. 


## Trees in data.tree

This package offers an alternative. The tree package allows you to create hierarchies, called `data.tree` structures. The building block of theses structures are `Node` objects. The package provides basic traversal, search, and sort operations, and an infrastructure for recursive tree programming. You can decorate `Node`s with your own attributes and methods, so as to extend the package to your needs. 

The package also provides convenient methods for neatly printing trees, and converting trees from and to `data.frame`s, `lists`, and other tree structures such as `dendrogram`, `phylo` objects from the ape package, `igraph`, and other packages.


# data.tree basics

## Tree creation

### Create a tree programmatically

Let's start by creating a tree of `Node`s. In our example, we are looking at a company, Acme Inc., and the tree reflects its organisational structure. The root (level 1) is the company. On level 2, the nodes represent departments, and the leaves of the tree represent projects that the company is considering for next year:

```{r}
library(data.tree)

acme <- Node$new("Acme Inc.")
  accounting <- acme$AddChild("Accounting")
    software <- accounting$AddChild("New Software")
    standards <- accounting$AddChild("New Accounting Standards")
  research <- acme$AddChild("Research")
    newProductLine <- research$AddChild("New Product Line")
    newLabs <- research$AddChild("New Labs")
  it <- acme$AddChild("IT")
    outsource <- it$AddChild("Outsource")
    agile <- it$AddChild("Go agile")
    goToR <- it$AddChild("Switch to R")

print(acme)
```

As you can see from the previous example, each `Node` is identified by its *name*, i.e. the argument you pass into the `Node$new(name)` function. The name needs to be *unique* among siblings, such that paths to `Nodes` are unambiguous.

Note also that `Node` is an `R6` reference class. This has the following implications:

1. You can call methods on a `Node` in OO style, e.g. `acme$Get("name")`
2. `Node` exhibits *reference semantics*. Thus, multiple variables in R can point to the same `Node`, and modifying a `Node` will modify it for all referencing variables. In the above code example, both `acme$IT` and `it` reference the same object. This is different from the *value semantics*, which is much more widely used in R.

### Create a tree from a data.frame

Creating a tree programmatically is useful especially in the context of algorithms. However, most times you will create a tree by conversion. This could be by conversion from a list-of-list, by conversion from another R tree-structure (e.g. an ape phylo), or by conversion from a `data.frame`. For more details on all the options type:

```{r eval=FALSE}
?as.Node
```

and refer to the See Also section.

One of the most common conversions is the one from a data.frame in table format. The following code illustrates this:

```{r}
library(treemap)
data(GNI2010)
#this data.frame is in table format, meaning that each row represents a
#leaf in the tree:
head(GNI2010)
#the pathString describes the hierarchy by defining a path from the
#root to each leaf. In this example, the hierarchy comes very naturally:
GNI2010$pathString <- paste("world", 
                            GNI2010$continent, 
                            GNI2010$country, 
                            sep = "/")

#conversion to Node is then very easy:
population <- as.Node(GNI2010)
print(population, "iso3", "population", "GNI", limit = 20)
```


### Create a tree from a file

Often, trees are created from one of many file formats. Typical import patterns could be:

* csv -> data.frame in table format (`?read.csv`) -> data.tree (`?as.Node.data.frame`)
* Newick -> ape phylo (`?ape::read.tree`) -> data.tree (`?as.Node.phylo` )
* csv -> data.frame in taxonomy / edge format (`?read.csv`) -> data.tree (c.f. `?FromDataFrameTaxonomy`)
* yaml -> list of lists (`?yaml::yaml.load`) -> data.tree (`?as.Node.list`, `demo('decisiontree', package='data.tree')`
* json -> list of lists (e.g. `?jsonlite::fromJSON`) -> data.tree (`?as.Node.list`)

If you have a choice, we recommend you consider yaml format, as it is concise, human-readable, and very easy to convert to a data.tree. An example of a sample population is provided here for illustration:

```{r}
library(yaml)
yaml <- "
name: OS Students 2014/15
OS X:
  Yosemite:
    users: 16
  Leopard:
    users: 43
Linux:
  Debian:
    users: 27
  Ubuntu:
    users: 36
Windows:
  W7:
    users: 31
  W8:
    users: 32
  W10:
    users: 4
"

osList <- yaml.load(yaml)
osNode <- as.Node(osList)
print(osNode, "users")
```

Once converted to a `data.tree` structure, we can use all its features to work with the hierarchical data. We will explain these functions later, but provide here a quick sample for illustration:

```{r}
#hierarchically sum up the users per OS
osNode$Do(function(x) Aggregate(node = x, 
                                attribute = "users", 
                                aggFun = sum, 
                                cacheAttribute = "users"))

#sort by users
osNode$Sort(attribute = "users", decreasing = TRUE, recursive = TRUE)

#print the tree, showing only OS having more than 20 users
print(node = osNode, "users", pruneFun = function(x) x$users > 20)

```



## Node methods

As seen above, a `data.tree` structure is composed of `Node` objects, and the entry point to a `data.tree` structure is always a `Node`, typically the root `Node` of a tree.

There are different types of methods:

* OO-style actives (sometimes called properties) on `Node`s, such as e.g. `Node$isRoot`
* OO-style methods on `Node`s, such as e.g. `Node$Prune(pruneFun)`
* Classical R methods, such as e.g. `Clone(node)`. The main reason for these are not design considerations, but performance. As OO-style methods maintain their own "copy" of the function in each `Node` instance, they are inflating memory usage of the `Node`s. For this reason, their use is kept to a minimum, and often only a classical R method exists instead.


### Actives Examples

Actives look like fields, but they are dynamically evaluated. Remember our population example:

```{r}
print(population, limit = 15)
population$isRoot
population$height
population$count
population$totalCount
population$fields
population$totalFields
population$averageBranchingFactor
```

The naming convention of the package is that fields and actives are lower case, whereas methods are upper / Camelcase.
RStudio and other IDEs work well with `data.tree`. If you have a `Node`, simply type `myNode$ + SPACE` to get a list of available attributes. 

### OO-Style Methods Examples

```{r}
#Get will traverse the tree and collect a specific attribute. More details below
sum(population$Get("population", filterFun = isLeaf))

#Prune traverses the tree and keeps only the subtrees for which the pruneFun returns TRUE
population$Prune(pruneFun = function(x) !x$isLeaf || x$population > 1000000)

#Note that the Prune function has side-effects, as it acts on the original population object.
#The population sum is now smaller
sum(population$Get("population", filterFun = isLeaf), na.rm = TRUE)
```


### Traditional R Methods

```{r}
popClone <- Clone(acme)

```

Traditional S3 generics are available especially for conversion:

```{r}
as.data.frame(acme)
```

Though there is also a more specialised non-generic version:

```{r}
ToDataFrameTaxonomy(acme)
```


## Climbing a tree (tree navigation)

To *climb* a tree means to navigate to a specific `Node` in the data.tree structure. The most natural is to climb a tree by `Node's` path.

### Navigation by path

Once you have a tree, you can localise any node by its path, where each path element is the name of a node:

```{r}
acme$IT$Outsource
acme$Research$`New Labs`
```

There is a number of other ways to get to a specific `Node`.

### Naviation by position

You can access the children of a `Node` directly through the `Node$children` attribute: 


```{r}

acme$children[[1]]$children[[2]]$name

```


### Navigation by attributes

You can not only navigate by path, but also by other attributes:

```{r}
acme$Climb(position = 1, name = "New Software")$name

```

As a shortcut, you can also specify the name of the attribute only once, like this:

```{r}
tree <- CreateRegularTree(5, 5)
tree$Climb(position = c(2, 3, 4))$path
```

Finally, you can even combine. The following example starts on the root, then looks for child at position 2. The in turn its child at position 3. Next its child having name = "4", and finally its child having name "5".

```{r}
tree$Climb(position = c(2, 3), name = c(4, 5))$path
```


## Custom attributes

Just as with, say, a `list`, we can add any custom attribute to any `Node` in a data.tree structure. Let's go back to our acme company and add costs and probabilities on the leaf nodes, i.e. the projects in each department:

```{r}
acme
software$cost <- 1000000
standards$cost <- 500000
newProductLine$cost <- 2000000
newLabs$cost <- 750000
outsource$cost <- 400000
agile$cost <- 250000
goToR$cost <- 50000

software$p <- 0.5
standards$p <- 0.75
newProductLine$p <- 0.25
newLabs$p <- 0.9
outsource$p <- 0.2
agile$p <- 0.05
goToR$p <- 1
print(acme, "cost", "p")
```

Note that there is a list of reserved names you cannot use as `Node` attributes:

```{r}
NODE_RESERVED_NAMES_CONST
```

## Outputting

### Printing

Printing a tree is easy. Printing displays a tree in a tree-grid view. On the left, you have the hierarchy. Then you have a column per variable you want to print:

```{r}

print(acme, "cost", "p")

```

You can use *formatters* to output a variable in a certain way:

```{r}
SetFormat(acme, "p", formatFun = FormatPercent)
SetFormat(acme, "cost", formatFun = FormatFixedDecimal)
print(acme, "cost", "p")

```

For even more flexibility, you can use tree-traversal to compose your data.frame. This is explained below. But just for your convenience, a simple example:

```{r}
data.frame(cost = acme$Get("cost", format = function(x) FormatFixedDecimal(x, 2)),
           p = acme$Get("p", format = FormatPercent))
           

```



### Converting to `data.frame`

As you saw just above, creating a `data.frame` by hand is easy. For some standard conversion types, the package offers convenience methods, and a generics `as.data.frame.Node` method.

Again, note that we always call such methods on the root `Node`:

```{r}
acmedf <- as.data.frame(acme)
```
The same can be achieved by using the more specialised method:
```{r, eval=FALSE}
ToDataFrameTree(acme)
```

We can also add attributes of the tree as columns to the `data.frame`:
```{r}
ToDataFrameTree(acme, "level", "cost")
```

Other data frame conversions are:

```{r}
ToDataFrameTable(acme, "pathString", "cost")
```

```{r}
ToDataFrameTaxonomy(acme, "cost")
```



### Plotting

`data.tree` is a data structure, and as such it does not offer its own printing facilities. However, R contains many packages that are well suited to print hierarchies.

For example, using dendrogram:

```{r}
plot(as.dendrogram(CreateRandomTree(nodes = 20)), center = TRUE)
```

Or, using igraph: 

```{r echo=FALSE }
library(igraph, quietly = TRUE, warn.conflicts = FALSE, verbose = FALSE)
```

```{r}
library(igraph)
plot(as.igraph(acme))
```

Another example, which at the same tame shows conversion from csv:

```{r}
library(curl)
#load all the presentations from useR15 in Aalborg
url <- curl("https://raw.github.com/gluc/useR15/master/00_data/useR15.csv")
useRdf <- read.csv(url)
#define the hierarchy (Session/Room/Speaker)
useRdf$pathString <- paste("useR", useRdf$session, useRdf$room, useRdf$speaker, sep="|")
#convert to Node
useRtree <- as.Node(useRdf, pathDelimiter = "|")

#plot with networkD3
library(networkD3)
useRtreeList <- ToListExplicit(useRtree, unname = TRUE)
network <- treeNetwork(useRtreeList)
network

```



There are many more examples in the package's demos. Type `demo(package = "data.tree")` for a list of available demos.

# Tree Traversal

Tree traversal is one of the core concepts of trees. See, for example, here: [Tree Traversal on Wikipedia](http://en.wikipedia.org/wiki/Tree_traversal).

## `Get` method

The `Get` method traverses the tree and collects values from each node. It then returns a vector containing the collected values. 

Additional features of the `Get` method are:

* execute a function on each node, and append the function's result to the returned vector
* execute a `Node` method on each node, and append the method's return value to the returned vector
* assign the function or method return value to a `Node`'s attribute


### Traversal order

The `Get` method can traverse the tree in various ways. This is called traversal order.

#### Pre-Order

The default traversal mode is **pre-order**. 

![pre-order](assets/preorder.png)

This is what is used e.g. in `print`:

```{r}
print(acme, "level")
```

#### Post-Order

The **post-order** traversal mode returns children first, returning parents only after all children have been traversed:

![post-order](assets/postorder.png)

We can use it like this on the `Get` method:

```{r}
data.frame(level = acme$Get('level', traversal = "post-order"))
```

This is useful if your parent's value depends on the children, as we'll see below.

#### Ancestor

This is a non-standard traversal mode that does not traverse the entire tree. Instead, the ancestor mode starts from a `Node`, then walks the tree along the path from ancestor to ancestor, up to the root.

```{r}

data.frame(level = agile$Get('level', traversal = "ancestor"))

```

### `Get` using a function

#### Pass a function to the `Get` method

You can pass a standard R function to the `Get` method. For example:

```{r}

ExpectedCost <- function(node) {
  result <- node$cost * node$p
  if(length(result) == 0) result <- NA
  return (result)
}

acme$Get(ExpectedCost, filterFun = isLeaf)

```

The requirements for the function (`ExpectedCost` in the above example) is that the first argument of the function is a `Node`.


#### Using recursion

In the following examples, we use `magrittr` to enhance readability of the code. 

```{r}
library(magrittr)
ExpectedCost <- function(node) {
  result <- node$cost * node$p
  if(length(result) == 0) {
    if (node$isLeaf) result <- NA
    else {
      node$children %>% sapply(ExpectedCost) %>% sum -> result
    }
  }
  return (result)
}

data.frame(ec = acme$Get(ExpectedCost))

```

#### Add parameters to the passed function

The `Traverse` method accepts an ellipsis (`...`). Any additional parameters with which `Get` is called will be passed on to the `ExpectedCost` function. This gives us more flexibility. For instance, we don't have to hard-code the `sum` function into `ExpectedCost`, but we can leave it to the caller to provide the function to use:

```{r}

ExpectedCost <- function(node, fun = sum) {
  result <- node$cost * node$p
  if(length(result) == 0) {
    if (node$isLeaf) result <- NA
    else {
      node$children %>% sapply(function(x) ExpectedCost(x, fun = fun)) %>% fun -> result
    }
  }
  return (result)
}

data.frame(ec = acme$Get(ExpectedCost, fun = mean))

```


## `Do` method

We can tell the `Do` method to assign the value to a specific attribute for each `Node` it traverses. This is especially useful if the attribute parameter is a function, as in the previous examples. For instance, we can store the calculated expected cost for later use and printing:

```{r}

acme$Do(function(x) x$expectedCost <- x$p * x$cost)
print(acme, "p", "cost", "expectedCost")

```


## `Set` method

The `Set` method is the counterpart to the `Get` method. The `Set` method takes a vector or a single value as an input, and traverses the tree in a certain order. Each `Node` is assigned a value from the vector, one after the other, recycling.

### Assigning values

```{r}
acme$Set(id = 1:acme$totalCount)

print(acme, "id")
```

The `Set` method can take multiple vectors as an input, and, optionally, you can define the name of the attribute. Finally, just as for the `Get` method, the **traversal order** is important for the `Set`.

```{r}
secretaries <- c(3, 2, 8)
employees <- c(52, 43, 51)
acme$Set(secretaries, 
         employees,
         filterFun = function(x) x$level == 2)
print(acme, "employees", "secretaries", "id")


```


### Deleting attributes

The `Set` method can also be used to assign a single value directly to all `Node`s traversed. For example, to remove the `avgExpectedCost`, we assign `NULL` on each node, using the fact that the `Set` recycles:

```{r}
acme$Set(avgExpectedCost = NULL)
```

## Explicit traversal

Previously, we have used the Get, Set and Do methods in their OO-style version. This is often very convenient for quick access to variables. However, often times you want to use the same traversal for various operations. For this reason, we have the explicit traversal mode. It works like so:

```{r}
traversal <- Traverse(acme, traversal = "post-order", filterFun = function(x) x$level == 2)
Set(traversal, floor = c(1, 2, 3))
Do(traversal, function(x) {
    if (x$floor <= 2) {
      x$extension <- "044"
    } else {
      x$extension <- "043"
    }
  })
Get(traversal, "extension")

```


# Advanced Features

## `Aggregate` method

The `Aggregate` method provides a shorthand for the oft-used case when a parent is the aggregate of its children values, as seen in the previous example. `Aggregate` calls a function recursively on children. For example:



```{r}
Aggregate(acme, "cost", sum)

```

We can use this in the `Get` method:

```{r, eval=FALSE}
acme$Get(Aggregate, "cost", sum)
```

We can also store/cache the calculated value along the way. For one thing, this is a convenient way to save an additional `Set` call. Additionally, it speeds up calculation:


```{r}

Aggregate(acme, function(x) x$cost * x$p, aggFun =  max, cacheAttribute = "expCost") 
print(acme, "expCost")

```


## `Cumulate` method

In its simplest form, the `Cumulate` function just sums up a value along siblings, taking into consideration all siblings before the node on which `Cumulate` is called:

```{r}
Cumulate(acme$IT$`Go agile`, "cost", sum)

```

Or, to find the minimum cost among siblings:

```{r}
Cumulate(acme$IT$`Go agile`, "cost", min)

```

This can be useful in combination with traversal, e.g. to calculate a running sum among siblings. Specifically, the `cacheAttribute` lets you store the running sum in a field. This not only speeds up calculation, but lets you re-use the calculated values later:

```{r}

acme$Do(function(node) Cumulate(node, 
                                attribute = "cost", 
                                aggFun = sum, 
                                cacheAttribute = "cumCost"))
print(acme, "cost", "cumCost")

```


## `Clone` method

As stated above, `Nodes` exhibit reference semantics. If you call, say, `Set`, then this changes the `Nodes` in the tree for all variables having a reference on the data.tree structure. As a consequence, you might want to "save away" the current state of a structure. To do this, you can `Clone` an entire tree:

```{r}
acmeClone <- Clone(acme)
acmeClone$name <- "New Acme"
# acmeClone does not point to the same reference object anymore:
acme$name == acmeClone$name
```


## `Sort` method

You can sort an entire tree, a sub-tree, or a `Node's` children by using the `Sort` method. The method will sort recursively and, for each `Node`, sort children by a child attribute. As before, the child attribute can also be a function or a method (e.g. of a sub-class of `Node`, see below).

```{r, eval=FALSE}
acme$Sort("name")
acme
acme$Sort(Aggregate, "cost", sum, decreasing = TRUE, recursive = TRUE)
acme
```

# Performance Considerations

## CPU

The data.tree package has been built to support visualization, to foster rapid prototyping, and for other applications where development time saved is more important than computing time lost. Having said this, it becomes clear that big data and data.tree do not marry particularly well. Do not try to build a data.tree structure with a few million `Nodes`. Do not try to convert a JSON document with a size of a gigabyte to a data.tree structure.

However, if you are respecting the following guidelines, I promise you will have a lot of fun with your `Nodes`:

1. Creating a `Node` is relatively expensive. `CreateRegularTree(6, 6)` creates a data.tree structure with 9331 `Nodes`. On my computer (a mid-end Notebook), this takes about 9 seconds.
2. `Clone` is similar to `Node` creation, with an extra penalty of about 20%.
3. Traversing (`Traverse`, `Get`, `Set` and `Do`) is realtively cheap. 

Just to give you an order of magnitude: The following times are achieved on wherever this document is built:

```{r}
system.time(tree <- CreateRegularTree(6, 6))
system.time(tree <- Clone(tree))
system.time(traversal <- Traverse(tree))
system.time(Set(traversal, id = 1:tree$totalCount))
system.time(ids <- Get(traversal, "id"))


leaves <- Traverse(tree, filterFun = isLeaf)
Set(leaves, leafId = 1:length(leaves))
system.time(Get(traversal, function(node) Aggregate(node, "leafId", max)))
#with caching, you can save some time:
system.time(tree$Get(function(node) Aggregate(tree, "leafId", max, "maxLeafId"), traversal = "post-order"))


```

## Memory

data.tree structures have a relatively large memory footprint. However, for every-day applications using modern computers, this will not normally have an impact on your work **except when saving a data.tree structure to disk**. 

For an explanation why that is the case, you might want to read this answer on [Stack Overflow](http://stackoverflow.com/questions/13912867/empty-r-environment-becomes-large-file-when-saved).

Depending on your development environment, you might want to turn off the option to save the workspace to .RData on exit.